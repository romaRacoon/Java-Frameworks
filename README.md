# Java-Frameworks
## Работа с БД. JDBC и Hibernate.
### [Задача 1](https://github.com/romaRacoon/PP1_1)
Задание:
1. Пройти 2 первых блока в приложении https://learngitbranching.js.org (Введение и Едем дальше).
2. Создать Git репозиторий на GitHub и залить туда пустой проект.
3. Склонируйте себе свой проект, используя IDE. Для этого необходимо выполнить следующие действия:

 1. На верхней панели найдите вкладку file -> new -> Project from Version Control...  
 2. В открывшемся окне, необходимо вставить в поле для ввода ссылку на репозиторий и нажать кнопку clone. Ссылку на репозиторий можно получить, нажав на кнопку Clone в вашем репозитории на https://github.com

### [Задача 2](https://github.com/romaRacoon/PP1_1)
Задание:
В этом задании мы познакомимся с такими технологиями, как:

 Maven  - https://maven.apache.org/
 JDBC - https://o7planning.org/ru/10167/java-jdbc-tutorial
 

Для выполнения задания необходимо:

 Клонировать/скачать заготовку по ссылке
 Установить на компьютер MySqlServer и Workbench. Создать подключение и схему через Workbench. Протестировать возможность соединения с базой через идею с помощью встроенной утилиты, как показано на рисунке:
Описание задачи:

Необходимо ознакомиться с заготовкой и доработать приложение, которое взаимодействует с базой оперируя пользователем ( класс User ) и проверить свои методы заранее написанными JUnit тестами. По итогу все тесты должны быть пройдены. Разрешается посмотреть реализацию тестов.

Для запуска теста необходимо найти класс в папке test ( показано в предыдущей лекции ) и при нажатии на него правой кнопкой мыши запустить, выбрав Run "Имя класса" 

Класс UserHibernateDaoImpl в рамках этой задачи не затрагивается (остаётся пустой)

User представляет из себя сущность с полями:

Long id
String name
String lastName
Byte age
         Архитектура приложения создана с опорой на паттерн проектирования MVC ( частично, у нас не WEB приложение)

Ознакомиться с паттерном можно здесь

 

Требования к классам приложения:

 Классы dao/service должны реализовывать соответствующие интерфейсы
 Класс dao должен иметь конструктор пустой/по умолчанию
 Все поля должны быть private
 service переиспользует методы dao
 Обработка всех исключений, связанных с работой с базой данных должна находиться в dao
 Класс Util должен содержать логику настройки соединения с базой данных
 

Необходимые операции:

 Создание таблицы для User(ов) – не должно приводить к исключению, если такая таблица уже существует
 Удаление таблицы User(ов) – не должно приводить к исключению, если таблицы не существует
 Очистка содержания таблицы
 Добавление User в таблицу
 Удаление User из таблицы ( по id )
 Получение всех User(ов) из таблицы
       

        Алгоритм работы приложения:

         В методе main класса Main должны происходить следующие операции:

 Создание таблицы User(ов)
 Добавление 4 User(ов) в таблицу с данными на свой выбор. После каждого добавления должен быть вывод в консоль ( User с именем – name добавлен в базу данных )
 Получение всех User из базы и вывод в консоль ( должен быть переопределен toString в классе User)
 Очистка таблицы User(ов)
 Удаление таблицы

### [Задача 3](https://github.com/romaRacoon/PP1_1/tree/secondTask)
В этом задании мы познакомимся с фреймворком Hibernate и научимся взаимодействовать с помощью него с базой данных.

Для выполнения задания необходимо:

 Ознакомиться с Hibernate. Подробнее узнать о Hibernate можно Здесь 
 Готовая прошлая задача ( работа будет происходить в этом же проекте )
 

Описание задачи:

В прошлой задаче мы познакомились с Maven и JDBC, доработали приложение, взаимодействующее с базой данных.

На этот раз обратим внимание на класс UserHibernateDaoImpl, который реализует тот же интерефейс, что и UserDaoJdbcImpl.

В рамках этой задачи необходимо реализовать взаимодействие с базой данных с помощью Hibernate и дописать методы в классе UserHibernateDaoImpl, проверить свои методы заранее написанными JUnit тестами из заготовки.

 

   Требования к классам приложения:

 UserHibernateDaoImpl должен реализовывать интерефейс UserDao
 В класс Util должна быть добавлена конфигурация для Hibernate ( рядом с JDBC), без использования xml.
 Service на этот раз использует реализацию dao через Hibernate
 Методы создания и удаления таблицы пользователей в классе UserHibernateDaoImpl должны быть реализованы с помощью SQL.
 

  Алгоритм приложения и операции не меняются в сравнении с предыдущим заданием.
  
  ## Введение в Spring
  ### [Задача 1](https://github.com/romaRacoon/IntroductionInSpring)
  Склонируйте заготовку проекта по ссылке.
Всего 3 класса и одна зависимость.
Класс App содержит метод main, который запускает Спринг при создании контекста. В контекст мы передаем класс AppConfig, который помечен аннотацией @Configuration - так Спринг понимает, что это настроечный класс.
В классе AppConfig содержится метод, помеченный аннотацией как бин, этот метод будет выполнен при запуске и его результат станет объектом, управляемым Спрингом.
Класс HelloWorld является обычным Java-классом, мы его используем без каких-либо сложностей.
В методе main мы можем получить бин HelloWorld по имени и использовать в любом месте программы.
Спринг позволяет использовать различные типы бинов, одни будут жить от старта до завершения программы, другие будут создаваться при каждом запросе или открытии новой сессии, третьи при каждом вызове будут создаваться новые. За это отвечает аннотация @Scope.

Задание:
1. Прочитайте про виды бинов.
2. Создайте POJO-класс Cat.
3. В классе AppConfig, по аналогии, создайте бин с именем “cat”.
4. Настройте этот бин так, чтобы он создавался новым при каждом запросе.
5. В классе App, по аналогии, вызовите еще раз бин HelloWorld, затем 2 раза вызовите бин cat. Сравните 2 пары бинов по ссылке и выведите результат в консоль. Для пары HelloWorld должно вернуться true, для cat - false. Так вы можете увидеть результат того, как работает наш контейнер.
6. Раскомментируйте тестовый класс и проверьте своё решение.

### [Задача 2](https://github.com/romaRacoon/IntroductionInSpring/tree/secondTask)
Склонируйте заготовку проекта по ссылке.
Поработаем со связыванием бинов.
Вызывать бины из контекста хорошо, но не так удобно, как связывать их автоматически.
Для работы аннотаций связывания, я добавил в Maven ядро Cпринга, так мы имеем совершенно рабочее Spring-приложение, пусть и без дополнительных модулей.
В компоненте AnimalCage есть поле типа Animal, которое связано с помощью аннотации @Autowired. При выполнении программы DI-контейнер подтянет сюда бин, подходящий по типу.

Задание:
1) Создайте бин Dog, унаследуйте его от Animal. Создайте на основе этого класса компонент.
2) Запустите приложение и проверьте, что было выброшено исключение NoUniqueBeanDefinitionException. Это произошло из-за того, что существует 2 бина с типом Animal.
3) Прочитайте о связывании бинов по имени и свяжите AnimalCage c бином Dog через абстрактный класс Animal.
4) На основе класса Timer создайте бин. Свяжите с AnimalCage. Проверьте, что при выполнении метода main время, которое пишет таймер, одно и тоже.
5) Раскоментировать тест из заготовки и проверить своё решение.

### [Задача 3](https://github.com/romaRacoon/IntroductionInSpring/tree/thirdTask)
Склонируйте заготовку проекта по ссылке.
«На море на океане есть остров, на том острове дуб стоит, под дубом сундук зарыт, в сундуке — заяц, в зайце — утка, в утке — яйцо, в яйце — игла, — смерть Кощея»
Зависимости остались прежние. В упражнении появился компонент Кощей Бессмертный (KoscheiTheDeathless), который расскажет, где находится его смерть, если вызвать метод getRulesByDeth().
Для описания поиска смерти использованы классы в пакете models. Для вашего удобства они были пронумерованы: Ocean1, Island2, Wood3 и так далее.
Чтобы Спринг видел все бины, в классе AppConfig была добавлена аннотация @ComponentScan.
В Спринге связать бины можно различными способами, рассмотрим их на примере:
1) KoscheiTheDeathless связывается с Ocean1 через сеттер setOcean и аннотации @Autowired над ней.
2) Ocean1 связан с Island2 через поле и аннотацию, которая подтянет бин Island2 через метод getIsland() в классе AppConfig. Обратите внимание, что данный метод обозначен аннотацией @Bean, что автоматически подтягивает аргументы в метод. В качестве аргумента выступает бин Wood3.
3) Бин Wood3 помечен как компонент, который конструируется через связывание по @Autowired с помощью конструктора.

Задание:
Собрать цепочку до 8го элемента, использовав все вышеперечисленные методы связывания. После выполнения вы должны получить полную фразу. Проверьте своё решение тестом из заготовки.

## ORM (Hibernate) и MVC
### [Задача 1](https://github.com/romaRacoon/ORM_Hibernate_MVC)
Скачайте/склонируйте заготовку проекта по ссылке.
С работой ядра Спринг мы разобрались, теперь самое время подключить к нему пару модулей для комфортной работы.
Начнем с ORM.
Для работы с hibernate нам понадобится зависимость hibernate-core, корректным взаимодействием со Спрингом озаботится зависимость spring-orm.
Как вы можете видеть, зависимость spring-core пропала, это произошло из-за того, что она является транзитной для всех модулей Спринга и дублировать ее смысла нет.
У нас появились пакеты model, service, теперь сервисы и DAO объявлены бинами с помощью аннотаций @Repository и @Service.
В методе main будет происходить тестирование работоспособности нашего приложения. Класс Car аннотирован как стандартная сущность hibernate. В AppConfig теперь присутствует базовая настройка hibernate, берущая данные из файла db.properties. Обратите внимание, что для ее работы используется аннотация @PropertySource("classpath:db.properties"), обращающаяся к папке ресурсов.
На этом настройка приложения окончена.

Задание:
1. Создайте соединение к своей базе данных и схему. Запустите приложение. Проверьте, что оно полностью работает.
2. Создайте сущность Car с полями String model и int series, на которую будет ссылаться User с помощью связи one-to-one.
3. Добавьте этот класс в настройки hibernate.
4. Создайте несколько пользователей с машинами, добавьте их в базу данных, вытащите обратно.
5. В сервис добавьте метод, который с помощью hql-запроса будет доставать юзера, владеющего машиной по ее модели и серии.

### [Задача 2](https://github.com/romaRacoon/ORM_HIBERNATE_SECONDTASK)
На данном этапе начинается самое интересное: ваше приложение начнет получать запросы и возвращать ответы. Плюс к этому, мы создадим приложение, которое будет запускаться и управляться с помощью сервера Tomcat. IDE поможет работать с ним без сложных консольных команд, что сильно облегчит разработку.
В этом приложении мы используем только зависимость spring-webmvc. Это не значит, что нам больше не нужны бины или контекст, в данном случае webmvc-фреймворк будет работать самостоятельно, так как любой фреймворк Спринга содержит в себе spring-core.
В приложении появился новый пакет controller, в котором содержатся классы, держащие группы сервлетов - контроллеры. Данная технология позволит нам избежать создания большого количества сервлетов. Контроллеры содержат методы, которые маппятся на разные url и http-методы, заменяя собой класс сервлета с методами doGet, doPost и т.д.
Для запуска приложения перейдите в Project Structure во вкладку Modules.
Выберите модуль spring_mvc и нажмите “+”. Далее следует выбрать модуль Spring и IDEA сама подтянет класс-иницилайзер WebConfig, если это не произошло автоматически, то пропишите абсолютный путь на этот файл.
Аналогично нужно создать модуль Web, но в этом случае путь должен ссылаться на папку webapp.

Теперь обратимся к сборке проекта, в файл pom.xml
Для правильной интерпретации структуры проекта требуется указать следующие параметры:
1) failOnMissingWebXml позволит нам запускать проект с помощью маппинга контроллерами, без использования конфигурации в web.xml.
2) warSourceDirectory должен ссылаться на папку, содержащую WEB-INF/
3) В конфигурации maven-compiler-plugin явно нужно прописать версию Java.
Для запуска перейдите в конфигурацию сервера
Настройте запуск приложения на свободный порт, выберите дефолтный Tomcat, измените адрес, который будет вызван после запуска, на /, так как в нашем приложении для этой страницы есть контроллер.
Далее следует настроить артефакт. Нажмите кнопку Fix, далее «+», выберите артефакт с именем “название проекта”-war exploded.
После этого подтвердите изменения и запускайте приложение.
Ваш браузер откроется автоматически и вы увидите страницу приветствия.

Отдельное внимание стоит уделить тому, что в приложении нет метода main, его запуск происходит из-под Tomcat и для этого требуется отдельный класс AppInit, который ссылается на корневой конфигурационный файл и обозначает, на каком url будет находиться наше приложение.
Задание:
1. Создайте еще один контроллер, замаппленный на /cars.
2. Создайте модель Car с тремя произвольными полями.
3. Создайте список из 5 машин.
4. Создайте сервис с методом, который будет возвращать указанное число машин из созданного списка.
5. Создайте страницу cars.html. Реализуйте создание таблицы с машинами из сервиса с помощью thymeleaf.
6. При запросе /cars выводить весь список. При запросе /cars?count=2 должен отобразиться список из 2 машин,
при /cars?count=3 - из 3, и тд. При count ≥ 5 выводить весь список машин.

## CRUD-приложение на Spring
### [Задача 1](https://github.com/romaRacoon/CRUD_APP_ON_SPRING)
Перейдем к созданию рабочего web-приложения. Все ключевые моменты были рассмотрены в предыдущих задачах. Теперь вам требуется их сопоставить и связать в один проект.
Используя наработки по mvc и hibernate соберите CRUD-приложение.

Задание:
1. Написать CRUD-приложение. Использовать Spring MVC + Hibernate.
2. Должен быть класс User с произвольными полями (id, name и т.п.).
3. В приложении должна быть страница, на которую выводятся все юзеры с возможностью добавлять, удалять и изменять юзера.
4. Конфигурация Spring через JavaConfig и аннотации, по аналогии с предыдущими проектами. Без использования xml. Без Spring Boot.
5. Внесите изменения в конфигурацию для работы с базой данных. Вместо SessionFactory должен использоваться EntityManager.

## Spring Boot, Spring Security и REST
### [Задача 1](https://github.com/romaRacoon/SpringBoot_Security_REST)
1. Необходимо перенести ваше CRUD-приложение на Spring Boot.

### [Задача 2](https://github.com/romaRacoon/SpringBoot_Security_REST/tree/seconTask)
Склонируйте проект по ссылке и просмотрите его.

Модуль Spring Security позволяет нам внедрять права доступа, а также контролировать их исполнение без ручных проверок.
Spring Security базируется на 2х интерфейсах, которые определяют связь сущностей с секьюрностью: UserDetails и GrantedAuthority.
UserDetails - то, что будет интерпретироваться системой как пользователь.
GrantedAuthority - сущность, описывающая права юзера.
Оба эти интерфейса имеют множество реализаций: просмотрите класс WebSecurityConfig, в методе configure() с помощью настроек userDetailsService() мы собираем единственный на всю программу экземпляр UserDetails с именем и паролем user , а его роль “USER” так же будет преобразована в экземпляр GrantedAuthority.

Это простейший способ создания секьюрности. Так же мы можем использовать jdbc-аутентификацию путем написания запроса, возвращающего пользователя и роль.
Как вы понимаете, такие способы максимально просты, но лишены достаточной гибкости, потому наиболее часто используемый вариант настройки выглядит как имплементация UserDetails и GrantedAuthority в классах-сущностях с переопределением существующих методов.

Рассмотрим приложение.
Новые классы:
- WebSecurityConfig- настройка секьюрности по определенным URL, а также настройка UserDetails и GrantedAuthority.
- LoginSuccessHandler - хэндлер, содержащий в себе алгоритм действий при успешной аутентификации. Например, тут мы можем отправить пользователя с ролью админа на админку после логина, а с ролью юзер на главную страницу сайта и т.п. 

Задание:
1. Перенесите классы и зависимости из предыдущей задачи.
2. Создайте класс Role и свяжите User с ролями так, чтобы юзер мог иметь несколько ролей.
3. Имплементируйте модели Role и User интерфейсами GrantedAuthority и UserDetails соответственно. Измените настройку секьюрности с inMemory на userDetailService.
4. Все CRUD-операции и страницы для них должны быть доступны только пользователю с ролью admin по url: /admin/.
5. Пользователь с ролью user должен иметь доступ только к своей домашней странице /user, где выводятся его данные. Доступ к этой странице должен быть только у пользователей с ролью user и admin. Не забывайте про несколько ролей у пользователя!
6. Настройте logout с любой страницы с использованием возможностей thymeleaf.
7. Настройте LoginSuccessHandler так, чтобы админа после аутентификации направляло на страницу /admin, а юзера на его страницу /user.
